{"meta":{"title":"Robin' s Blog","subtitle":null,"description":null,"author":"Robin","url":"http://www.luorubin.top"},"pages":[{"title":"About Me","date":"2016-12-10T16:32:28.404Z","updated":"2016-12-10T16:32:28.404Z","comments":true,"path":"about/index.html","permalink":"http://www.luorubin.top/about/index.html","excerpt":"","text":"(/▽╲)"},{"title":"Categories","date":"2016-12-10T16:28:44.601Z","updated":"2016-12-10T16:28:44.601Z","comments":true,"path":"categories/index.html","permalink":"http://www.luorubin.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-12-10T16:28:53.088Z","updated":"2016-12-06T21:21:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.luorubin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"快速排序","slug":"快速排序","date":"2015-08-01T12:13:11.000Z","updated":"2017-01-01T13:48:58.100Z","comments":true,"path":"2015/08/01/快速排序/","link":"","permalink":"http://www.luorubin.top/2015/08/01/快速排序/","excerpt":"基本思想通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。","text":"基本思想通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 java代码实现及流程利用快速排序对以下N个整数进行升序排序（N=5）： 13 27 49 35 4 步骤： 记下标s为0，下标e为（数组长度-1）。取出数组第一个元素作为基准元素（当一个元素从数组中被取出时，该元素所在位置相当于变成一个空的“桶”）。 从后往前遍历数组，每遍历一个元素就e–，当遇到比基准元素小的，a[e]放进“桶”。此时，a[e]所在位置变成“桶”。 从前往后遍历数组，每遍历一个元素就s++，当遇到比基准元素大的，a[s]放进“桶”。此时，a[s]所在位置变成“桶”。 当s == e时，此时a[s]和a[e]为同一个“桶”，把基准元素放进。到此步时，基准元素前面的元素都会比它小，基准元素后面的元素都会比它大。 a[0…s-1]和a[s+1…N-1]各自成一个区间，递归执行前三步，直到分割的区间只有一个元素。 代码：12345678910111213141516171819202122232425262728293031323334353637private static void QuickSort(int[] arr, int l, int h)&#123; if (l &lt; h) &#123; //经过一趟排序后，上一趟的基准元素所在的正确位置 int pivot = partion(arr, l, h); //对上一趟的基准元素前面的元素排序 QuickSort(arr, l, pivot - 1); //对上一趟的基准元素后面的元素排序 QuickSort(arr, pivot + 1, h); &#125;&#125;private static int partion(int[] arr, int start, int end) &#123; //一趟排序后的目标：所有比基准小的在基准前，比基准大的在基准后 int tmp = arr[start];//选第一个元素为基点 while (start &lt; end) &#123; //从后面起，比基准大的，略过这个元素，直到找的一个比基准小的 while (arr[end] &gt;= tmp &amp;&amp; start &lt; end) end--; if (start &lt; end) &#123; //经过前面从后往前的遍历后，如果s小于e，则说明找到了一个比基准小的元素，把这个元素赋值到s后s++ arr[start++] = arr[end]; &#125; while (arr[start] &lt; tmp &amp;&amp; start &lt; end) //从前面起，比基准小的，略过这个元素，直到找的一个比基准大的 start++; if (start &lt; end) &#123; //经过前面从前往后的遍历后，如果s小于e，则说明找到了一个比基准大的元素，把这个元素赋值到e后e-- arr[end--] = arr[start]; &#125; &#125; //经过以上从后往前、从前往后的两个遍历，此时s等于e，把基准元素赋值进去 arr[start] = tmp; return start;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://www.luorubin.top/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.luorubin.top/tags/排序/"}]},{"title":"插入排序","slug":"插入排序","date":"2015-07-28T07:23:22.000Z","updated":"2017-01-01T05:59:30.191Z","comments":true,"path":"2015/07/28/插入排序/","link":"","permalink":"http://www.luorubin.top/2015/07/28/插入排序/","excerpt":"基本思想每步将一个待排序的纪录，按其值的大小插入到前面已经排序的记录中适当位置上，直到全部插入完为止。","text":"基本思想每步将一个待排序的纪录，按其值的大小插入到前面已经排序的记录中适当位置上，直到全部插入完为止。 java代码实现及流程利用插入排序对以下N个整数进行升序排序（N=5）： 13 27 49 35 4 步骤： 初始时，a[0]自成1个有序区，无序区为a[1…n-1]。令i=1。 将a[i]插入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。 i++并重复第二步直到i==N-1，排序完成。 注意：在第二步中，待插入元素插入有序区时，一般做法是将待插入元素跟有序区元素逐个比较，直到找到待插入下标后，下标和下标后面的元素全部向后“挪动”一个位置，再将待插入元素插入到待插入下标。关于这步，其实可以采用冒泡排序的思想，即将待插入元素跟有序区元素从后往前逐个比较，如果待插入元素比某个元素值小，则交换他们，直到遇到比某个元素大则插入结束。这种做法比传统的元素向后“挪动”效率更高。 代码：123456789public void InsertionSort(int[] arr) &#123; int i, j;//i为当前待插入元素下标，j初始为已排好序区间的最后一个元素 //循环从已排好序区间后面，比较和i元素的大小，如果比i元素大，则交换位置，直到遇到比i元素小，则i元素排好序了 for (i = 1; i &lt; arr.length; i++) &#123; for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; Swap(arr, j, j + 1); &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次插入后: 13 27 49 35 4 第1次插入后: 13 27 49 35 4 第2次插入后: 13 27 49 35 4 第3次插入后: 13 27 35 49 4 第4次插入后: 4 13 27 35 49","categories":[{"name":"算法","slug":"算法","permalink":"http://www.luorubin.top/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.luorubin.top/tags/排序/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2015-07-27T08:45:53.000Z","updated":"2016-12-18T12:53:06.638Z","comments":true,"path":"2015/07/27/冒泡排序/","link":"","permalink":"http://www.luorubin.top/2015/07/27/冒泡排序/","excerpt":"基本思想重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。","text":"基本思想重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 java代码实现及流程利用冒泡排序对以下N个整数进行升序排序（N=5）： 13 27 49 35 4 第一种实现思路步骤： 比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。 这样对数组的下标0的数到下标N-1的数据进行一次遍历后，最大的一个数据就“沉”到数组下标N-1。 N=N-1，如果N不为0就重复前面二步，否则排序完成。 代码： 123456789public void BubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 1; j &lt; arr.length - i; j++) &#123; if (arr[j - 1] arr[j]) &#123; Swap(arr, j - 1, j); &#125; &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次比较后: 13 27 49 35 4 第1次比较后: 13 27 49 35 4 第2次比较后: 13 27 35 49 4 第3次比较后: 13 27 35 4 49 第4次比较后: 13 27 35 4 49 第5次比较后: 13 27 35 4 49 第6次比较后: 13 27 4 35 49 第7次比较后: 13 27 4 35 49 第8次比较后: 13 4 27 35 49 第9次比较后: 4 13 27 35 49 第二种实现思路步骤： i=0，将下标i的数跟后面逐个数比较一直到下标N-1的数，如果下标i的数大于后面的某个数据，就将二个数据交换。 这样对数组的下标i的数据到下标N-1的数据进行一次遍历后，最大的一个数据就“浮”到数组第i个位置。 i=i+1，如果i+1小于N就重复前面二步，否则排序完成。 代码：123456789public void BubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; Swap(arr, i, j); &#125; &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次比较后: 13 27 49 35 4 第1次比较后: 13 27 49 35 4 第2次比较后: 13 27 49 35 4 第3次比较后: 4 27 49 35 13 第4次比较后: 4 27 49 35 13 第5次比较后: 4 27 49 35 13 第6次比较后: 4 13 49 35 27 第7次比较后: 4 13 35 49 27 第8次比较后: 4 13 27 49 35 第9次比较后: 4 13 27 35 49","categories":[{"name":"算法","slug":"算法","permalink":"http://www.luorubin.top/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.luorubin.top/tags/排序/"}]}]}