{"meta":{"title":"Robin' s Blog","subtitle":null,"description":null,"author":"Robin","url":"http://www.luorubin.top"},"pages":[{"title":"About Me","date":"2016-12-10T16:32:28.404Z","updated":"2016-12-10T16:32:28.404Z","comments":true,"path":"about/index.html","permalink":"http://www.luorubin.top/about/index.html","excerpt":"","text":"(/▽╲)"},{"title":"Categories","date":"2016-12-10T16:28:44.601Z","updated":"2016-12-10T16:28:44.601Z","comments":true,"path":"categories/index.html","permalink":"http://www.luorubin.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-12-10T16:28:53.088Z","updated":"2016-12-06T21:21:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.luorubin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"冒泡排序","slug":"冒泡排序","date":"2015-07-27T08:45:53.000Z","updated":"2016-12-18T12:53:06.638Z","comments":true,"path":"2015/07/27/冒泡排序/","link":"","permalink":"http://www.luorubin.top/2015/07/27/冒泡排序/","excerpt":"基本思想重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。","text":"基本思想重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 java代码实现及流程利用冒泡排序对以下N个整数进行升序排序（N=5）： 13 27 49 35 4 第一种实现思路步骤： 比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。 这样对数组的下标0的数到下标N-1的数据进行一次遍历后，最大的一个数据就“沉”到数组下标N-1。 N=N-1，如果N不为0就重复前面二步，否则排序完成。 代码： 123456789public void BubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 1; j &lt; arr.length - i; j++) &#123; if (arr[j - 1] arr[j]) &#123; Swap(arr, j - 1, j); &#125; &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次比较后: 13 27 49 35 4 第1次比较后: 13 27 49 35 4 第2次比较后: 13 27 35 49 4 第3次比较后: 13 27 35 4 49 第4次比较后: 13 27 35 4 49 第5次比较后: 13 27 35 4 49 第6次比较后: 13 27 4 35 49 第7次比较后: 13 27 4 35 49 第8次比较后: 13 4 27 35 49 第9次比较后: 4 13 27 35 49 第二种实现思路步骤： i=0，将下标i的数跟后面逐个数比较一直到下标N-1的数，如果下标i的数大于后面的某个数据，就将二个数据交换。 这样对数组的下标i的数据到下标N-1的数据进行一次遍历后，最大的一个数据就“浮”到数组第i个位置。 i=i+1，如果i+1小于N就重复前面二步，否则排序完成。 代码：123456789public void BubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; Swap(arr, i, j); &#125; &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次比较后: 13 27 49 35 4 第1次比较后: 13 27 49 35 4 第2次比较后: 13 27 49 35 4 第3次比较后: 4 27 49 35 13 第4次比较后: 4 27 49 35 13 第5次比较后: 4 27 49 35 13 第6次比较后: 4 13 49 35 27 第7次比较后: 4 13 35 49 27 第8次比较后: 4 13 27 49 35 第9次比较后: 4 13 27 35 49","categories":[{"name":"算法","slug":"算法","permalink":"http://www.luorubin.top/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.luorubin.top/tags/排序/"}]}]}