{"meta":{"title":"Robin' s Blog","subtitle":null,"description":null,"author":"Robin","url":"http://www.luorubin.top"},"pages":[{"title":"About Me","date":"2016-12-10T16:32:28.404Z","updated":"2016-12-10T16:32:28.404Z","comments":true,"path":"about/index.html","permalink":"http://www.luorubin.top/about/index.html","excerpt":"","text":"(/▽╲)"},{"title":"Categories","date":"2016-12-10T16:28:44.601Z","updated":"2016-12-10T16:28:44.601Z","comments":true,"path":"categories/index.html","permalink":"http://www.luorubin.top/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-12-10T16:28:53.088Z","updated":"2016-12-06T21:21:38.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.luorubin.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"插入排序","slug":"插入排序","date":"2015-07-28T07:23:22.000Z","updated":"2016-12-18T16:02:39.564Z","comments":true,"path":"2015/07/28/插入排序/","link":"","permalink":"http://www.luorubin.top/2015/07/28/插入排序/","excerpt":"基本思想每步将一个待排序的纪录，按其值的大小插入到前面已经排序的记录中适当位置上，直到全部插入完为止。","text":"基本思想每步将一个待排序的纪录，按其值的大小插入到前面已经排序的记录中适当位置上，直到全部插入完为止。 java代码实现及流程利用冒泡排序对以下N个整数进行升序排序（N=5）： 13 27 49 35 4 步骤： 初始时，a[0]自成1个有序区，无序区为a[1…n-1]。令i=1。 将a[i]插入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。 i++并重复第二步直到i==N-1，排序完成。 注意：在第二步中，待插入元素插入有序区时，一般做法是将待插入元素跟有序区元素逐个比较，直到找到待插入下标后，下标和下标后面的元素全部向后“挪动”一个位置，再将待插入元素插入到待插入下标。关于这步，其实可以采用冒泡排序的思想，即将待插入元素跟有序区元素从后往前逐个比较，如果待插入元素比某个元素值小，则交换他们，直到遇到比某个元素大则插入结束。这种做法比传统的元素向后“挪动”效率更高。 代码：123456789public void InsertionSort(int[] arr) &#123; int i, j;//i为当前待插入元素下标，j初始为已排好序区间的最后一个元素 //循环从已排好序区间后面，比较和i元素的大小，如果比i元素大，则交换位置，直到遇到比i元素小，则i元素排好序了 for (i = 1; i &lt; arr.length; i++) &#123; for (j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) &#123; Swap(arr, j, j + 1); &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次插入后: 13 27 49 35 4 第1次插入后: 13 27 49 35 4 第2次插入后: 13 27 49 35 4 第3次插入后: 13 27 35 49 4 第4次插入后: 4 13 27 35 49","categories":[{"name":"算法","slug":"算法","permalink":"http://www.luorubin.top/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.luorubin.top/tags/排序/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2015-07-27T08:45:53.000Z","updated":"2016-12-18T12:53:06.638Z","comments":true,"path":"2015/07/27/冒泡排序/","link":"","permalink":"http://www.luorubin.top/2015/07/27/冒泡排序/","excerpt":"基本思想重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。","text":"基本思想重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 java代码实现及流程利用冒泡排序对以下N个整数进行升序排序（N=5）： 13 27 49 35 4 第一种实现思路步骤： 比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。 这样对数组的下标0的数到下标N-1的数据进行一次遍历后，最大的一个数据就“沉”到数组下标N-1。 N=N-1，如果N不为0就重复前面二步，否则排序完成。 代码： 123456789public void BubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 1; j &lt; arr.length - i; j++) &#123; if (arr[j - 1] arr[j]) &#123; Swap(arr, j - 1, j); &#125; &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次比较后: 13 27 49 35 4 第1次比较后: 13 27 49 35 4 第2次比较后: 13 27 35 49 4 第3次比较后: 13 27 35 4 49 第4次比较后: 13 27 35 4 49 第5次比较后: 13 27 35 4 49 第6次比较后: 13 27 4 35 49 第7次比较后: 13 27 4 35 49 第8次比较后: 13 4 27 35 49 第9次比较后: 4 13 27 35 49 第二种实现思路步骤： i=0，将下标i的数跟后面逐个数比较一直到下标N-1的数，如果下标i的数大于后面的某个数据，就将二个数据交换。 这样对数组的下标i的数据到下标N-1的数据进行一次遍历后，最大的一个数据就“浮”到数组第i个位置。 i=i+1，如果i+1小于N就重复前面二步，否则排序完成。 代码：123456789public void BubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; Swap(arr, i, j); &#125; &#125; &#125;&#125; 比较过程： 原始排序: 13 27 49 35 4 第0次比较后: 13 27 49 35 4 第1次比较后: 13 27 49 35 4 第2次比较后: 13 27 49 35 4 第3次比较后: 4 27 49 35 13 第4次比较后: 4 27 49 35 13 第5次比较后: 4 27 49 35 13 第6次比较后: 4 13 49 35 27 第7次比较后: 4 13 35 49 27 第8次比较后: 4 13 27 49 35 第9次比较后: 4 13 27 35 49","categories":[{"name":"算法","slug":"算法","permalink":"http://www.luorubin.top/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://www.luorubin.top/tags/排序/"}]}]}